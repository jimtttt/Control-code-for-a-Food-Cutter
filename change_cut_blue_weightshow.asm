	;Aug 28: ADD BLUETOOTH TO change_cut.asm, --> change_cut_blue.asm
	;Aug 27: MAKE CHANGE TO changeA.asm, --> change_cut.asm
	;CUT    <-> MOTOR A
	;CHANGE <-> MOTOR B
	;PUSH	<-> MOTOR C
	;CONNECTION:
	.EQU	CLK7, 90H
	.EQU	DT, 91H
	.EQU	DIO, 92H
	.EQU	RCK, 93H
	.EQU	SCK, 94H
	.EQU	BUTA, 0A5H	;4 FOR CHOOSING KNIFES	
	.EQU	BUTB, 0A6H
	.EQU	BUTC, 0B6H
	.EQU	BUTD, 0B7H
	.EQU	BUTE, 0B5H	;CUTTING

	.EQU	DIRA, 0A0H	;P2.0 TO CONTROL MOTOR A DIRECTION
	.EQU	PULA, 0A1H	;P2.1 TO PROVIDE MOTOR A PULSE
	.EQU	EXCA, 0A2H	;P2.2 FOR MOTOR A EXCITATION
				;MOTOR B DIR IS UNCONNECTED AND IS FINE
	.EQU	PULB, 0A7H	;P2.3 TO PROVIDE MOTOR B PULSE
	.EQU	DIRC, 0A3H	;P2.4 TO CONTROL MOTOR C DIRECTION
	.EQU	PULC, 0A4H	;P2.5 TO PROVIDE MOTOR C PULSE

	.EQU	RECEI, 0B0H	;P3.0, RXD OF 51  RECEIVE <-
	.EQU	TRANS, 0B1H	;P3.1 TXD OF 51,  TRASMIT ->

	;START PLACE
	LJMP	MAIN
	.ORG	0BH
	LJMP	TIMER0
	.ORG	1BH
	LJMP	TIMER1
	.ORG	23H
	LJMP	SERIAL
	.ORG	30H
;-------MAIN: 4+1 BUTTONS VERSION
MAIN:	MOV	3BH, #0
	MOV	39H, #6
	MOV	3AH, #255
	SETB	DIRA
	;timer0:motors, timer1:weight_show, timer2:serial_blue
	;original: 21H, 2:timer1 for serial int, 1:timer0 for motors
	;now: 1:timer1 for hx711 and screen, 1:timer0 for motors
	MOV	TMOD, #11H	
	MOV	TL0, #0C8H
	MOV	TH0, #0FBH
	MOV	TL1, #00H	;LONGER TIME WHEN JUST INSPECT
	MOV	TH1, #00H
	;65500 = FFDCH
	MOV	0CAH, #0DCH
	MOV	0CBH, #0FFH	;BLUETOOTH, RCAP2H
	MOV	3CH, #0C8H
	MOV	3DH, #0FBH
	MOV	IE, #9AH	;CHANGE 82H TO 92H
	;MOV	DPTR, #PARA
	;MOV	TH1, #0FDH	;FROM blue-sw.asm
	MOV	SCON, #50H
	MOV	3EH, #0		;CURRENT POSITION (0-3)
	;MOV	3FH, #0
	;MOV	40H, #0FFH
	CLR	04H		;NOT CHANGING
	CLR	05H		;NOT CUTTING
	CLR	06H
	;THE ABOVE TWO CANNOT BE 1 AT THE SAME TIME
	SETB	EXCA		;1/16 AT FIRST
	SETB	DIRC		;DOWN AT FIRST
	;COUNT DOWN FOR CUTTING PROCESS
	MOV	41H, #0C0H
	MOV	42H, #5DH	;07D0H = 2000D, 1F40H = 4000D
	MOV	43H, #'C'
	MOV	44H, #'\0'
	MOV	45H, #'0'
	MOV	46H, #'\0'
	MOV	47H, #'1'
	MOV	48H, #'\0'
	MOV	49H, #'2'
	MOV	4AH, #'\0'
	MOV	4BH, #'3'
	MOV	4CH, #'\0'
	MOV	4DH, #'G'	;SEND GOOD BACK
	MOV	4EH, #'\0'
	CLR	07H		;NO NEED TO SEND
	MOV	4FH, #50H	;TO RECEIVE
	MOV	52H, #4DH	;TO TRANSMIT
	;from weight_show.asm and use timer2
	MOV	30H, #00010110B
	MOV	31H, #00000101B
	MOV	32H, #00010110B
	MOV	33H, #00000101B
	MOV	34H, #0H	;DISPLAY 30 TIMES, BUT FIRST PUT 0
	CLR	03H		;INDICATE TO INSPECT
	;PRIORITY, SERIAL AND TIMER0 IS HIGH, TIMER1 IS LOW 
	MOV	IP, #00010010B
	;timer1(weight) start at first
	SETB	TR1
	;timer2(baudrade generator need to start too)
	MOV	0C8H, #34H		;T2CON, USED FOR SERIAL AND START
	;T2MOD IS FINE UPON RESET
B0:	JNB	BUTA, B1
	MOV	40H, #0H
	ACALL	SETT
B1:	JNB	BUTB, B2
	MOV	40H, #1H
	ACALL	SETT
B2:	JNB	BUTC, B3
	MOV	40H, #2H
	ACALL	SETT
B3:	JNB	BUTD, B4
	MOV	40H, #3H
	ACALL	SETT
B4:	JNB	BUTE, B0
	ACALL	SETT1
	SJMP	B0

;-------SERIAL: HANDLE BLUETOOTH COMMAND
	;CURRENT REVEIVE PTR IN 4FH, IT CONTAINS 50 OR 51H
	;TRANSMIT PTR IN 52H, IT CONTAINS 4D OR 4EH
	;PUT RECEIVED MESSAGE IN 50/51H
SERIAL:	JB	TI, TRANSI	;TRANSIMIT INTERRUPT
	;SO RECEIVE INTERRUPT IS HIGH
	MOV	A, SBUF
	PUSH	00H		;SAVE R0 ANYWAY
	MOV	R0, 4FH
	MOV	@R0, A
	JNZ	NOTCOMP		;NOT COMPLETE
	;RECEIVED '\0', BEGIN TO COMPARE
	MOV	4FH, #4FH	;TO BECOME 50H
	SETB	07H		;NEED TO SEND
	ACALL	WHICH
	;IN A, 0 - 3 FOR KNIFES, 4 FOR CUT
	CJNE	A, #4, SCHAN	;SERIAL CHANGE
	;FOR CUT
	ACALL	SETT1
	SJMP	NOTCOMP	;TOTORET ORIGINALLY
SCHAN:	MOV	40H, A
	ACALL	SETT
NOTCOMP:INC	4FH
	CLR	RI
	POP	00H
	RETI
TRANSI:	JNB	07H, JEND
	PUSH	00H
	MOV	R0, 52H
	MOV	A, @R0
	JNZ	MORE
	MOV	52H, #4CH	; TOO BECOME 4DH
	CLR	07H
MORE:	POP	00H
	MOV	SBUF, A
	INC	52H
JEND:	CLR	TI
	RETI

;-------WHICH: FIND WHICH COMMAND
	;RECEIVED THING AT 50H, CURRENT POS IN R0: 43H TO START
	;RETURN: IN A, 0 TO 3 FOR KNIFES, 4 FOR CUT, 255 FOR ERROR
WHICH:	MOV	R0, #43H
LOOOP:	MOV	A, @R0
	CJNE	A, 50H, NEXT
	;SO THIS IS A MATCH
	INC	R0
	MOV	A, @R0
	CJNE	A, 51H, ERRCMD
	;TWO MATCH, FOUND, NEED TO SEE R0 IS WHAT
	;POSSIBLE IN R0: 44H, 46H, 48H, 4AH, 4CH
	;		 C    0	   1    2    3
	MOV	A, R0
	CJNE	A, #44H, NEXTC	;NEXT COMPARE
	;4 FOR CUT
	MOV	A, #4
	RET
NEXTC:	CLR	C
	SUBB	A, #46H
	RR	A
	RET
NEXT:	MOV	A, R0
	CJNE	A, 4BH, RENEXT
	;ERROR CMD
ERRCMD:	MOV	A, #255
	RET
RENEXT:	INC	R0
	INC	R0
	SJMP	LOOOP

;-------SETT: DO THE REPEAT THING FOR MAIN(CHANGING)
SETT:	JNB	05H, GOON
	RET
GOON:	MOV	3FH, 40H
	MOV	A, 3EH
	CJNE	A, 3FH, RUNM
	RET
RUNM:	SETB	04H	;INDICATES CHANGING
	SETB 	TR0
	RET
;-------SETT1: FOR MAIN(CUTTING)
SETT1:	JNB	04H, GOON1
	RET
GOON1:	SETB	05H
	SETB	TR0
	RET

;-------TIMER0: CHANGE KNIFE TO THE NEXT OR PUSH&CUT
	;ALL DATA:
	;39H: # OF 255S
	;3AH: DIRECTLY COUNT
	;3BH: CURRENT STAGE, 0 - 5D
	;3CH->3DH: CURRENT TL0/TH0
	;DIRA: THE DIRECTION IS AT SOME POINTS CPLED
TIMER0:	JB	04H, CHGCHG
	;CUTCUT
	;2 STAGES: DOWN AND UP
	;06H: 0 FOR DOWN, 1 FOR UP
CUTCUT:	CLR	EXCA
	CLR	DIRA
	MOV	A, 41H
	DEC	A
	MOV	41H, A
	CJNE	A, #0FFH, NOCA
	DEC	42H
NOCA:	JNZ	GOON2
	;41H IS 0
	MOV	A, 42H
	JNZ	GOON2
	;SHOULD END NOW OR START UP STAGE
	MOV	41H, #0C0H
	MOV	42H, #5DH
	CPL	DIRC
	JNB	06H, UPSTART
	CLR	05H
	CLR	06H
	CLR	TR0
	MOV	TL0, #0C8H
	MOV	TH0, #0FBH
	SETB	DIRA
	SETB	EXCA
	RETI
UPSTART:SETB	06H
GOON2:	CPL	PULC
	JB	06H, FASTER	;FASTER
	CPL	PULA
	MOV	TL0, #0ECH
	MOV	TH0, #0FDH
	RETI
FASTER:	MOV	TL0, #00H
	MOV	TH0, #0FFH
	RETI
CHGCHG:	MOV	A, 3BH
	CJNE	A, #2, AROLL
	SJMP	BROLL
AROLL:	CPL	PULA
	CJNE	A, #4, BROLL
	SJMP	CONT0
BROLL:	CPL	PULB
CONT0:	MOV	A, 3AH
	DEC	A
	MOV	3AH, A
	JNZ	CONT1
	;0 IN 3AH, NEED GET SOME
	MOV	A, 39H
	JNZ	CONT2
	;0 IN 39H TOO, PREPARE FOR NEXT STAGE
	MOV	A, 3BH
	INC	A
	CJNE	A, #6, CONT3
	;A HAS 6, BACK TO 0 AND STOP TIME IF DESIRED POS REACHED
	MOV	A, 3EH	;CURRENT POSITION
	INC	A
	CJNE	A, #4, NTFOUR
	MOV	A, #0
NTFOUR:	MOV	3EH, A
	CJNE	A, 3FH, DTSTOP
	CLR	TR0
	CLR	04H	;NOT CHANGING ANYMORE
DTSTOP:	MOV	A, #0
CONT3:	MOV	3BH, A
	JZ	CDIR	;CHANGE DIRECTION
	CJNE	A, #2, CONT4
CDIR:	CPL	DIRA
CONT4:	PUSH	82H
	PUSH	83H	;DPTR LOW AND HIGH
	MOV	DPTR, #PARA
	RL	A
	RL	A
	ANL	A, #0FCH
	;A HAS BEEN MULTIPLIED BY 4
	PUSH	0E0H		;ACC
	MOVC	A, @A+DPTR	;# OF 255S PUT IN 39H
	MOV	39H, A
	POP	0E0H
	INC	A
	MOV	3AH, #255	;ALWAYS 255 AT FIRST
	INC	A
	PUSH	0E0H
	MOVC	A, @A+DPTR
	MOV	3CH, A
	POP	0E0H
	INC	A
	MOVC	A, @A+DPTR
	MOV	3DH, A
	POP	82H
	POP	83H
CONT1:	MOV	TL0, 3CH
	MOV	TH0, 3DH
	RETI
CONT2:	DEC	A
	MOV	39H, A
	JZ	LASTT
	;A STILL NOT 0
	MOV	3AH, #255
	SJMP	CONT1
LASTT:	MOV	A, 3BH
	RL	A
	RL	A
	ANL	A, #0FCH
	INC	A
	PUSH	82H
	PUSH	83H
	MOV	DPTR, #PARA
	MOVC	A, @A+DPTR
	MOV	3AH, A
	POP	82H
	POP	83H
	SJMP	CONT1

;-------TIMER1: INTERRUPT HANDLER, USE RETI
	;ALL IN MODE 1,	 TH1   	TL1
	;	    MAX	 00H	00H
	;	   20MS  B8H	00H 
	;SCRATCH PAD 34H: # OF 20MS WHEN DISPALYING WAITING TO INSPECT
	;
	;WHEN JUMP HERE, TF IS CLEARED
TIMER1:	MOV	C, 03H
	JNC	TOSHIFT
	;TOSHOW
	ACALL	SHOW		;IN R4R5R6R7, ITS PROBLEMATIC SINCE
				;IT CANNOT BE CHANGED
	MOV	A, 34H
	DEC	A
	MOV	34H, A
	JNZ	CONTIS		;CONTINUE TO SHOW
	CLR	03H
CONTIS:	MOV	TL1, #00H
	MOV	TH1, #0B8H
	RETI 
TOSHIFT:ACALL	SHIFT2		;RESULTS IN R1R2
	MOV	R0, #32H	;FIRST COMPARE
	ACALL	COMPARE		;RESULT IN 02H
	MOV	C, 02H
	JC	FAR1		;FIRST FAR
	MOV	R0, #30H
	ACALL	COMPARE
	MOV	C, 02H
	JC	FAR2
	;BOTH CLOSE
	MOV	TL1, #00H
	MOV	TH1, #00H
	CLR	03H
	RETI
FAR1:	MOV	33H, R1
	MOV	32H, R2
	MOV	A, R1
	MOV	R5, A
	MOV	A, R2
	MOV	R6, A
	ACALL	CONVERT		;PATTERNS IN R4R5R6R7
FAR2:	MOV	TL1, #00H
	MOV	TH1, #0B8H
	SETB	03H
	MOV	34H, #30
	RETI

;-------COMPARE: COMPARE TWO 16-BIT NUMBER
	;PARAM1: ADDR IN R0, PARAM2: IN R1>R2
	;RETURN: IN BIT ADDR 02H, 0 FOR THEY ARE CLOSER THAN 8, 1 OTHERWISE
	;REGISTERS TO MESS UP: A, 35H, 36H
	;(ADDR R0+1) -> (ADDR R0)
	; R1	     ->  R2
	; 36H	     ->  35H
COMPARE:CLR	02H
	MOV	A, R2		;CURRENT VALUE READ FROM HX711
	CLR	C		;LOW BYTE, NO CARRY
	SUBB	A, @R0		;MODIFY C FOR HIGH BYTE
	MOV	35H, A
	INC	R0		;ADDR OF HIGH BYTE, C IS FINE
	MOV	A, R1
	SUBB	A, @R0		;NOW CHECK C
	MOV	36H, A
	DEC	R0		;SO RO IS GOOD AFTER THE CALL
	JNC	POSI		;POSI: MY VALUE IN R5R6 IS LARGER
	;MY VALUE IS SMALLER, SO FLAP IT
	CPL	A
	MOV	36H, A
	MOV	A, 35H
	CPL	A
	INC	A
	MOV	35H, A
	JNZ	POSI
	;NEED TO INC R3
	INC	36H
	;NOW R3R4 IS THE DIFFERENCE BETWEEN TWO PARAMS(POSITIVE VALUE)
POSI:	MOV	A, 36H
	JNZ	FAR
	MOV	A, 35H
	ANL	A, #0F8H
	JNZ	FAR
	RET
FAR:	SETB	02H
	RET

;-------CONVERT: THE 24 BITS GIVEN BY HX711 -> THE 4 DIGITS TO SHOW
	;PARAM: IN R5, R6
	;RETURN: IN R7, R6, R5, R4 (THE BIT PATTERN)
	;REGISTERS TO MESSUP: R7, R6, R5, R4, A, R3/R2 AS COUNTERS
CONVERT:CLR	C	; NO BORROW, ITS THE LEAST SIGNIFICANT BYTE
	MOV	A, R6	; LEAVE R7 ALONE
	SUBB	A, #00010110B
	MOV	R6, A
	MOV	A, R5
	SUBB	A, #00000101B
	MOV	R5, A
	JNC	DIVSTAR	;DIVIDE START
	MOV	R6, #0H
	MOV	R5, #0H
	MOV	A, R5
	;NOW MULTIPLY R5R6 WITH 0.57 WHICH IS NOT FUN HAHA
	;DIVIDE BY 2 FIRST: SHIFT TO RIGHT
DIVSTAR:RRC	A
	ANL	A, #7FH	;CLEAR THE MOST SIGNIFICANT BIT, C IS FINE
	MOV	R4, A	; A COPY IN R4R7
	MOV	R5, A
	MOV	A, R6
	RRC	A	;NOW C CONTAINS GARBAGE I ASSUME
	MOV	R7, A
	MOV	R6, A	;NOW R5R6 IS HALF THE ORIGINAL VALUE
	MOV	R2, #2H
LOOP3:	MOV	R3, #3H	; DIVIDE AND PLUS (1/2 + 1/16 + 1/128)
LOOP2:	MOV	A, R4
	RRC	A
	ANL	A, #7FH
	MOV	R4, A
	MOV	A, R7
	RRC	A
	MOV	R7, A	;R4R7 IS A HALF
	DJNZ	R3, LOOP2
	;R4R7 IS 1/8, TIME FOR PLUS
	ADD	A, R6
	MOV	R6, A
	MOV	A, R4
	ADDC	A, R5
	MOV	R5, A	;NOW R5R6 IS UPDATED
	DJNZ	R2, LOOP3
	;NOW R5R6 CONTAINS 0.57 THE ORIGINAL VALUE
	;AND TIME FOR CONVERT HEX TO DECIMAL, WHICH IS NOT FUN EITHER
	MOV	R3, #0H	;2^0 - 2^12(4096) TO BE ADDED, OFFSET TO BCDL
	MOV	DPTR, #BCDL
	MOV	R4, #0H
	MOV	R7, #0H
LOOP4:	MOV	A, R5
	RRC	A	;BIT 0 IN C
	MOV	R5, A
	MOV	A, R6
	RRC	A	;BIT WANTED IN C
	MOV	R6, A
	JNC	NEXTB
	;IF THIS BIT IS 1
	MOV	A, R3	;THE OFFSET
	MOVC	A, @A+DPTR	;01H(AND NEXT OOH) FOR THE FIRST
	ADD	A, R7
	DA	A
	MOV	0H, C		;SAVE C
	MOV	R7, A
	MOV	A, R3
	ADD	A, #0DH		;BCDL TO BCDH
	MOVC	A, @A+DPTR
	MOV	C, 0H
	ADDC	A, R4
	DA	A
	MOV	R4, A
NEXTB:	INC	R3
	CJNE	R3, #0DH, LOOP4
	;R4R7 IS THE BCD NUMBER (0-5000 I NEED)
	;REPLACE THEM IN R7(L) - R4(H)
	SETB	01H		;THE BIT IN 01H, DISPLAY 0 OR NOT
	MOV	DPTR, #LCDPAT	;REPLACE DIGITS WITH THE BIT PATTERN
	MOV	A, R4
	MOV	R5, A
	ANL	A, #0F0H
	SWAP	A		;FOR R4
	JNZ	DISP1
	MOV	A, #0AH
	CLR	01H
DISP1:	MOVC	A, @A+DPTR
	MOV	R4, A
	MOV	A, R5
	ANL	A, #0FH
	JNZ	DISP20
	JB	01H, DISP2
	MOV	A, #0AH
	SJMP	DISP2
DISP20:	SETB	01H
DISP2:	MOVC	A, @A+DPTR
	MOV	R5, A
	MOV	A, R7
	ANL	A, #0F0H
	SWAP	A
	JNZ	DISP30
	JB	01H, DISP3
	MOV	A, #0AH
	SJMP	DISP3
DISP30: SETB	01H
DISP3:	MOVC	A, @A+DPTR
	MOV	R6, A
	MOV	A, R7
	ANL	A, #0FH
	JNZ	DISP40
	JB	01H, DISP4
	MOV	A, #0AH
	SJMP	DISP4
DISP40:	SETB	01H
DISP4:	MOVC	A, @A+DPTR
	MOV	R7, A
	RET

;-------SHIFT2: SHIFT 24 BITS DATA IN FROM HX711
	;PARAM: NONE
	;RETURN: 24 BITS IN R1 > R2 > 38H (LSB)
	;REGISTERS TO MESS UP: R3, R1, R2, 38H, A
SHIFT2:	CLR	CLK7
HH0:	JB	DT, HH0
	MOV	R3, #24
SHIFT:	SETB	CLK7
	NOP
	CLR	CLK7
	MOV	C, DT
	XCH	A, 38H
	RLC	A
	XCH	A, 38H
	XCH	A, R2
	RLC	A
	XCH	A, R2
	XCH	A, R1
	RLC	A
	XCH	A, R1
	DJNZ	R3, SHIFT
	SETB	CLK7
	NOP
	CLR	CLK7
	RET

;-------SHOW: DISPLAY THE 4 BYTES
	;PARAM: THE DATA, IN R7, R6, R5, R4
	;RETURN: NONE
	;REGISTERS TO MESS UP: A
SHOW:	MOV	A, R7
	ACALL	OUT
	MOV	A, #1H
	ACALL	OUT
	CLR	RCK
	SETB	RCK
	MOV	A, R6
	ACALL	OUT
	MOV	A, #2H
	ACALL	OUT
	CLR	RCK
	SETB	RCK
	MOV	A, R5
	ACALL	OUT
	MOV	A, #4H
	ACALL	OUT
	CLR	RCK
	SETB	RCK
	MOV	A, R4
	ACALL	OUT
	MOV	A, #8H
	ACALL	OUT
	CLR	RCK
	SETB	RCK
	MOV	A, #0FFH
	ACALL	OUT
	MOV	A, #1H
	ACALL	OUT
	CLR	RCK
	SETB	RCK
	RET

;-------OUT: PUT A BYTE OUT
	;PARAM: THE PATTERN TO PUT, IN A
	;RETURN: NONE;
	;REGISTERS TO MESS UP: R3, A
OUT:	MOV	R3, #8H
LOOP1:	RLC	A
	MOV	DIO, C
	CLR	SCK
	SETB	SCK
	DJNZ	R3, LOOP1	
	RET

;-------DELAY: DELAY FOR 20MS
DELAY:	MOV	R3, #40
H2:	MOV	R2, #255
H1:	DJNZ	R2, H1
	DJNZ	R3, H2
	RET

	.ORG	1000H
	;FOR EVERY STAGE
	;# OF 255S(+1), PLUS THE ONE, TL0, TH0
PARA:	.BYTE	6, 70, 0C8H, 0FBH, 6, 70, 0E4H, 0FDH, 4, 48, 0E4H, 0FDH
	.BYTE	4, 198, 0C8H, 0FBH, 4, 48, 0C8H, 0FBH, 3, 149, 0C8H, 0FBH

BCDL:	.BYTE	01H, 02H, 04H, 08H, 16H, 32H, 64H, 28H, 56H, 12H, 24H, 48H, 96H
BCDH:	.BYTE	00H, 00H, 00H, 00H, 00H, 00H, 00H, 01H, 02H, 05H, 10H, 20H, 40H
	;0-9 PATTERN SHOWN ON LCD, PLUS NOTHING
LCDPAT:	.BYTE	0C0H, 0F9H, 0A4H, 0B0H, 99H
	.BYTE	92H, 82H, 0F8H, 80H, 90H, 0FFH
